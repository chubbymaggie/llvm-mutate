                                                           -*- org -*-
* Tasks [0/2]
** cut must correctly handle deletion of final instruction in block
do this by folding it into its successor
: /// FoldBlockIntoPredecessor - Folds a basic block into its predecessor if it
: /// only has one predecessor, and that predecessor only has one successor.
: /// The LoopInfo Analysis that is passed will be kept consistent.
: /// Returns the new combined block.
: static BasicBlock *FoldBlockIntoPredecessor(BasicBlock *BB, LoopInfo* LI,

#+begin_src C++
  // If this is a terminator instruction we might have problems.
  if(!isa<TerminatorInst>(I)){
    BasicBlock *BB = I->getParent();
    // merge into following block if only one exists
    if(BB->getTerminator()->getNumSuccessors() != 1){
      errs() << "can't merge with multiple subsequent blocks\n";
    } else {
      Function::iterator I = BB;
      Function::iterator E = BB->getParent()->end();
      if(BB == E){
        errs() << "can't delete terminator of last block\n";
      } else {
        BasicBlock *Succ = I++;
        if (! Succ->getSinglePredecessor()){
          errs() << "next block has multiple preds, can't merge\n";
          return false;
        } else {
          // merge with the following block
          FoldSingleEntryPHINodes(Succ);
          BB->getInstList().pop_back();
          Succ->replaceAllUsesWith(BB);
          BB->getInstList().splice(BB->end(), Succ->getInstList());
          Succ->eraseFromParent(); } } } }
#+end_src

** TODO populated inserted instruction arguments from scope
When inserting an instruction we need to do two things.

1. find arguments from the current scope, =replaceOperands=.

   - RemapInstruction
     : /// RemapInstruction - Convert the instruction operands from referencing the
     : /// current values into those specified by VMap.
     : static inline void RemapInstruction(Instruction *I, ValueToValueMapTy &VMap)

     this is used a couple of places =RemapInstruction=, read its documentation

   - get arguments from nearby instructions
     : ->getOperand(0)

   - set operand to something specific
     : Clone->setArgOperand(0, Op);

   - add input operands to an instruction
     : // Insert new integer induction variable.
     : PHINode *NewPHI = PHINode::Create(Int32Ty, 2, PN->getName()+".int", PN);
     : NewPHI->addIncoming(ConstantInt::get(Int32Ty, InitValue),
     :                     PN->getIncomingBlock(IncomingEdge));

   - operation iterator
     : user->op_iterator()

2. assign its result into something in the current scope, this could
   be as simple as just taking the next instruction which requires an
   argument of the same type as the inserted instruction

** TODO swap is really just two replaces
To replace we need to,

1. replace everything using the original with the new, this is done
   by =ReplaceInstWithInst=

2. replace all arguments of the new with arguments of the original
   (or appropriate arguments selected from the environment)
   : replaceOperands

* Notes
** use-def and def-use
file:../../../docs/ProgrammersManual.html
see Iterating over def-use & use-def chains


** similarly read more about the value class and use user iterators
